Artifact description
====================

This artifact is the implementation of the algorithms of the paper "Proactive Synthesis of Recursive Tree-to-String Functions from Examples".
In `src/main/scala`, under the package name `prosy`, you can find the implementation in Scala of the 3 algorithms of the paper.
We provide the first two algorithms for consistency. However, since the third algorithm generalizes the first two, our artefact walkthrough is only about the third and most important algorithm, the proactive one.

In `src/main/scala`, under the package name `example`, you can find some examples that can be given to the command line of our tool.

This artifact can be run through the Scala Built Tool, alias `sbt`.

How to use the artifact
=======================

Prerequisites
-------------

Have git
Have SBT installed and on the path.
Clone the following directory using git:

  git clone https://github.com/epfl-lara/prosy
  
Test your installation by doing

  sbt compile

It should work fine.

Walkthrough 1
-------------

We will show Printer for a Context-Free grammar, the example of the paper, with some variations.

Errors in input.



Walkthrough 2
-------------
We will show an example of how doubling the size of the type system multiplies by 8 the number of
examples in the test set, but fortunately for us multiplies only by 2 the number of questions.
This example is also interesting because we can force the system to ask how to print any element among 
the test set of elements which is of *cubic* size.

For that, we imagine the type system available in

    src/main/scala/example/sample-cubic2.scala

Note that this type system allows the existence of exactly 2 + 4 + 8 = 14 unique elements: C1_(), C2_(), B1_(C2_()) ...
A1_(B2_(C1_()))... A2_(B2_(C2_())). The name end with _ because of the parser.

Let us define two transducers that we want to learn by example. The first one is `print`, the second `disp`

```scala
def print(t: Any): String = t match {
  case A1_(t1) => print(t1) + "01"
  case A2_(t1) => print(t1)
  case B1_(t1) => print(t1)
  case B2_(t1) => "0" + print(t1) + "1"
  case C1_() => "10"
  case C2_() => ""
}

def disp(t: Any): String = t match {
  case A1_(t1) => "01" + disp(t1)
  case A2_(t1) => disp(t1)
  case B1_(t1) => disp(t1)
  case B2_(t1) => "0" + disp(t1) + "1"
  case C1_() => "10"
  case C2_() => ""
}
```

These two transducers always display the same output, except for the unique value `A1_(B1_(C1()))`,
for which `print` displays `1001` and `disp` displays `0110`.
Since the role of `A1_` and `A2_` is interchangeable, and similarly for `B` and `C`,
we can make two transducers differ exactly on one chosen element, here `A1_(B1_(C1()))`.

Let us learn `print` by launching the command:

    sbt "run src/main/scala/example/sample-cubic2.scala"

Here is the walkthrough of the interaction. When there is A? it means that it asks how to print A.
Answer using the characters at the right of the arrow, and then press ENTER. If nothing is displayed, just press ENTER.

```
C2_ ? => (nothing)
C1_ ? => 10
B1_(C1_) ? => 10
B2_(C1_) ? => 0101
A2_(B2_(C1_)) ? => 0101
A1_(B1_(C2_)) ? => 01
A1_(B2_(C1_)) ? => 2
A1_(B1_(C1_)) ? => 2
```

Note that we could have entered `0` instead of `2` and then the output ourselves. If you make a mistake for `B1_(C1_)` and put `01` instead, it complains that it is not consistent and re-asks the question.
Similarly, if at a choice question we answer something which is out of bounds, it will re-ask the question.
Answering 1 to the last question gives exactly the function `disp`.

Without any errors, we obtain the statistics :

```
14 elements computed in test set:
  6 elements automatically inferred
  8 questions asked.
    3 regular questions
    3 with an hint of the type [...]foo[...]
    2 with explicit suggestions
```

Now let us run the second one which has twice as many classes:

    sbt "run src/main/scala/example/sample-cubic4.scala"

Here we learn similarly but we treat `A2_`, `A3_` and `A4_` the same way, same for `B` and `C`.

```
C4_ => 
C3_ => 
C2_ => 
C1_ => 10
B3_(C2_) => 01
B2_(C4_) => 01
B4_(C2_) => 01
B1_(C1_) => 10
B2_(C1_) => 1
B3_(C1_) => 1
B4_(C1_) => 1
A2_(B2_(C1_)) => 0101
A4_(B3_(C2_)) => 01
A1_(B1_(C2_)) => 01
A3_(B3_(C3_)) => 01
A1_(B2_(C4_)) => 2
A1_(B1_(C1_)) => 2
```

You obtain the following statistics:

```
Statistics:
84 elements computed in test set:
  67 elements automatically inferred
  17 questions asked.
    8 regular questions
    4 with an hint of the type [...]foo[...]
    5 with explicit suggestions
```

Note that the number of question doubled from 8 to 17, whereas the number of elements that could have been ambiguous was roughly multiplied by 8 from  14 to 84.

The order of questions, when there is choice, is to ask questions with the least number of solutions first.




